-- File generated by bch.exe program.
-- The decoder for BCH code (255,171), t=11
-- Option= 3,  Interleave= 1, -- with optimization= 1.
-- GF(2^8) is generated by polynomial [1+x+...] - 101110001;


-------------------------------------------------------------------
-- 2-1 multiplexer

	USE WORK.const.ALL;
ENTITY dmul21 IS
PORT ( sel: IN BIT;
	d0, d1: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dmul21;

ARCHITECTURE dmul21a OF dmul21 IS
  BEGIN
	gen:
	FOR i IN 0 TO m-1 GENERATE
	  dout(i)<= (NOT sel AND d0(i)) OR (sel AND d1(i));
	END GENERATE;
END dmul21a;

--------------------------------------------------------------------
-- single register with clock enable

ENTITY drd1ce IS
PORT ( clk, ce, din: IN BIT;
	dout: OUT BIT);
END drd1ce;

ARCHITECTURE drd1cea OF drd1ce IS
	SIGNAL q: BIT;
  BEGIN
	dout<= q;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF ce='1' THEN
		q<= din;
	ELSE
		q<= q;
	END IF;
  END PROCESS;
END drd1cea;

--------------------------------------------------------------------
-- PIPO registers m bits wide with clock enable and reset

	USE WORK.const.ALL;
ENTITY drdcer IS
PORT ( clk, ce, reset: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END drdcer;

ARCHITECTURE drdcera OF drdcer IS
	SIGNAL q: BIT_VECTOR(0 TO m-1);
  BEGIN
	dout<= q;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	FOR i IN 0 TO m-1 LOOP
	  IF reset='1' THEN
		q(i)<= '0';
	  ELSIF ce='1' THEN
		q(i)<= din(i);
	  ELSE
		q(i)<= q(i);
	  END IF;
	END LOOP;
  END PROCESS;
END drdcera;

--------------------------------------------------------------------
-- PIPO registers m bits wide with clock enable and set to one

	USE WORK.const.ALL;
ENTITY drdceSOne IS
PORT ( clk, ce, set, dinone: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END drdcesone;

ARCHITECTURE drdcesonea OF drdcesone IS
	SIGNAL q: BIT_VECTOR(0 TO m-1);
  BEGIN
	dout<= q;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF set='1' THEN
		q(0)<= dinone;
	ELSIF ce='1' THEN
		q(0)<= din(0);
	ELSE
		q(0)<= q(0);
	END IF;

	FOR i IN 1 TO m-1 LOOP
	  IF set='1' THEN
		q(i)<= '0';
	  ELSIF ce='1' THEN
		q(i)<= din(i);
	  ELSE
		q(i)<= q(i);
	  END IF;
	END LOOP;
  END PROCESS;
END drdcesonea;


--------------------------------------------------------------------
-- m registers with clock enable

	USE WORK.const.ALL;
ENTITY drdce IS
PORT ( clk, ce: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END drdce;

ARCHITECTURE drdcea OF drdce IS
	SIGNAL q: BIT_VECTOR(0 TO m-1);
  BEGIN
	dout<= q;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF ce='1' THEN
		q<= din;
	ELSE
		q<= q;
	END IF;
  END PROCESS;
END drdcea;
--------------------------------------------------------------------
-- PIPO registers m bits wide

	USE WORK.const.ALL;
ENTITY drd IS
PORT (clk: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END drd;

ARCHITECTURE drda OF drd IS
	SIGNAL q: BIT_VECTOR(0 TO m-1);
  BEGIN
	dout<= q;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	q<= din;
  END PROCESS;
END drda;

-- sum m * XOR; dout<= din0 XOR din1

	USE WORK.const.ALL;
ENTITY dxorm IS
PORT (din0, din1: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dxorm;

ARCHITECTURE dxorma OF dxorm IS
  BEGIN
	dout<= din0 XOR din1;
END dxorma;

-----------------------------------------------------------------

--------------- OPTION 3 -serial
-------------------------------------------------------------------
-- Serial In Parallel Out m bits shift register

	USE WORK.const.ALL;
ENTITY dsipo IS
PORT (clk, din: IN BIT;
	dout: OUT BIT_VECTOR(0 TO m-1));
END dsipo;

ARCHITECTURE dsipoa OF dsipo IS
	SIGNAL q: BIT_VECTOR(0 TO m-1);
  BEGIN
	dout<= q;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	q<= din & q(0 TO m-2);
  END PROCESS;
END dsipoa;

-------------------------------------------------------------------
-- Shift register with serial XOR, and parallel in

	USE WORK.const.ALL;
ENTITY dshpe IS
PORT (clk, ce, pe: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1); -- parallel in
	dout: OUT BIT_VECTOR(0 TO m-1));
END dshpe;

ARCHITECTURE dshpea OF dshpe IS
	SIGNAL ring: BIT_VECTOR(0 TO m-1);
  BEGIN
	dout<= ring;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe= '1' THEN
	  ring<= din;
	ELSIF ce='1' THEN
	  ring<= ring(m-1) & ring(0 TO m-2);
	END IF;
  END PROCESS;
END dshpea;

-------------------------------------------------------------------
-- Shift register with serial XOR, and reset

	USE WORK.const.ALL;
ENTITY dshr IS
PORT (clk, ce, reset, din: IN BIT;
	dout: OUT BIT_VECTOR(0 TO m-1));
END dshr;

ARCHITECTURE dshra OF dshr IS
	SIGNAL ring: BIT_VECTOR(0 TO m-1);
	SIGNAL dmul1: BIT;
  BEGIN
	dout<= ring;
	dmul1<= ring(m-1) XOR din;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF reset='1' THEN
	  ring(0)<= '0';
	ELSIF ce='1' THEN
	  ring(0)<= ring(m-1) XOR din;
	END IF;

	FOR i IN 1 TO m-1 LOOP
	  IF reset= '1' THEN
	    ring(i)<= '0';
	  ELSIF ce='1' THEN
	    ring(i)<= ring(i-1);
	  END IF;
	END LOOP;
  END PROCESS;
END dshra;

---------------------------------------------------------------------
-- dout<= en And din

	USE WORK.const.ALL;
ENTITY dandm IS
PORT (en: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dandm;

ARCHITECTURE dandma OF dandm IS
  BEGIN
	gen:
	FOR i IN 0 TO m-1 GENERATE
	  dout(i)<= din(i) AND en;
	END GENERATE;
END dandma;


---------------------------------------------------------------------
---------------------------------------------------------------------
-- buffer circuit

	USE WORK.const.ALL;
ENTITY dbuf IS
PORT (clk, bufCe, bufkCe, err, vdout1, din: IN BIT;
	dout: OUT BIT);
END dbuf;

ARCHITECTURE dbufa OF dbuf IS
	CONSTANT buf_size: INTEGER:= 110;
	-- buf_size= chpe/interleave + 2 if buf_size<k+1; else buf_size= k
	SIGNAL bufk: BIT_VECTOR(0 TO k-1);
	-- bufk - first buffer for storing only first k bits
	SIGNAL buf: BIT_VECTOR(0 TO buf_size-1); -- second buffer
  BEGIN
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF bufCe='1' THEN
		buf<= bufk(k-1) & buf(0 TO buf_size-2);
	END IF;
	IF bufkCe='1' THEN
		bufk<= din & bufk(0 TO k-2);
	END IF;
	dout<= (buf(buf_size-1) XOR err) AND vdout1;
  END PROCESS;
END dbufa;

-----------------------------------------------------------------
-- Bit-Serial Berlekamp (Dual Basis) Multiplier without registers

	USE WORK.const.ALL;
ENTITY dsdbm IS
PORT (dbin, sbin: IN BIT_VECTOR(0 TO m-1); -- standard & dual basis input
	dout: OUT BIT); -- serial output
END dsdbm;

ARCHITECTURE dsdbma OF dsdbm IS
	SIGNAL dxor: BIT_VECTOR(0 TO m-1); -- xor gates signals
  BEGIN
	dout<= dxor(m-1);
	dxor(0)<= sbin(0) AND dbin(0);
	gen:
	FOR i IN 1 TO m-1 GENERATE
	  dxor(i)<= dxor(i-1) XOR (sbin(i) AND dbin(i));
	END GENERATE;
END dsdbma;

-----------------------------------------------------------------
--  Bit-Serial Berlekamp (Dual Basis) Multiplier LFSR

	USE WORK.const.ALL;
ENTITY dsdbmRing IS
PORT (clk, pe: IN BIT;   -- pe- parallel enable
	din: IN BIT_VECTOR(0 TO m-1); -- dual basis input
	dout: OUT BIT_VECTOR(0 TO m-1));
END dsdbmRing;

ARCHITECTURE dsdbmRinga OF dsdbmRing IS
	SIGNAL ring: BIT_VECTOR(0 TO m-1);
  BEGIN
	dout<= ring;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  ring<= din;
	ELSE
	  ring(0 TO m-2)<= ring(1 TO m-1);
	  ring(m-1)<= ring(0) XOR ring(2) XOR ring(3) XOR ring(4);
	END IF;
  END PROCESS;
END dsdbmRinga;

-------------------------------------------------------------------
-- Bit-Parallel Dual-Basis Multiplier

	USE WORK.const.ALL;
ENTITY dpdbm IS
PORT (ddin, dsin: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dpdbm;

ARCHITECTURE dpdbma OF dpdbm IS
	COMPONENT dsdbm -- Serial Dual Basis Multiplier without registers
	  PORT (dbin, sbin: IN BIT_VECTOR(0 TO m-1);
		  -- dual & standard basis in
		dout: OUT BIT);
	  END COMPONENT;
	  FOR ALL: dsdbm USE ENTITY WORK.dsdbm (dsdbma);

	SIGNAL aux: BIT_VECTOR(0 TO m-2); -- auxiliary signals
	SIGNAL m0in, m1in, m2in, m3in, m4in, m5in, m6in, m7in: BIT_VECTOR(0 TO m-1);
  BEGIN
	aux(0)<= ddin(0) XOR ddin(2) XOR ddin(3) XOR ddin(4);
	aux(1)<= ddin(1) XOR ddin(3) XOR ddin(4) XOR ddin(5);
	aux(2)<= ddin(2) XOR ddin(4) XOR ddin(5) XOR ddin(6);
	aux(3)<= ddin(3) XOR ddin(5) XOR ddin(6) XOR ddin(7);
	aux(4)<= ddin(4) XOR ddin(6) XOR ddin(7) XOR aux(0);
	aux(5)<= ddin(5) XOR ddin(7) XOR aux(0) XOR aux(1);
	aux(6)<= ddin(6) XOR aux(0) XOR aux(1) XOR aux(2);
	m0in<= ddin(0) & ddin(1) & ddin(2) & ddin(3) & ddin(4) & ddin(5) & ddin(6) & ddin(7);
	m1in<= ddin(1) & ddin(2) & ddin(3) & ddin(4) & ddin(5) & ddin(6) & ddin(7) & aux(0);
	m2in<= ddin(2) & ddin(3) & ddin(4) & ddin(5) & ddin(6) & ddin(7) & aux(0) & aux(1);
	m3in<= ddin(3) & ddin(4) & ddin(5) & ddin(6) & ddin(7) & aux(0) & aux(1) & aux(2);
	m4in<= ddin(4) & ddin(5) & ddin(6) & ddin(7) & aux(0) & aux(1) & aux(2) & aux(3);
	m5in<= ddin(5) & ddin(6) & ddin(7) & aux(0) & aux(1) & aux(2) & aux(3) & aux(4);
	m6in<= ddin(6) & ddin(7) & aux(0) & aux(1) & aux(2) & aux(3) & aux(4) & aux(5);
	m7in<= ddin(7) & aux(0) & aux(1) & aux(2) & aux(3) & aux(4) & aux(5) & aux(6);
	m0:  dsdbm
		PORT MAP (m0in, dsin, dout(0));
	m1:  dsdbm
		PORT MAP (m1in, dsin, dout(1));
	m2:  dsdbm
		PORT MAP (m2in, dsin, dout(2));
	m3:  dsdbm
		PORT MAP (m3in, dsin, dout(3));
	m4:  dsdbm
		PORT MAP (m4in, dsin, dout(4));
	m5:  dsdbm
		PORT MAP (m5in, dsin, dout(5));
	m6:  dsdbm
		PORT MAP (m6in, dsin, dout(6));
	m7:  dsdbm
		PORT MAP (m7in, dsin, dout(7));

END dpdbma;

-------------------------------------------------------------------
-- Bit-Parallel Multiplier

	USE WORK.const.ALL;
ENTITY dpm IS
PORT (din1, din2: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dpm;

ARCHITECTURE dpma OF dpm IS
	COMPONENT dsdbm -- Serial Dual Basis Multiplier without registers
	  PORT (dbin, sbin: IN BIT_VECTOR(0 TO m-1);
		  -- dual & standard basis in
		dout: OUT BIT);
	  END COMPONENT;
	  FOR ALL: dsdbm USE ENTITY WORK.dsdbm (dsdbma);

	SIGNAL b: BIT_VECTOR(0 TO 28);
	SIGNAL c0, c1, c2, c3, c4, c5, c6, c7: BIT_VECTOR(0 TO m-1);
  BEGIN
	b(0 TO m-1)<= din1;
	b(8)<= b(1) XOR b(7);
	b(9)<= b(2) XOR b(7);
	b(10)<= b(3) XOR b(7);
	b(11)<= b(0) XOR b(6);
	b(12)<= b(8) XOR b(6);
	b(13)<= b(9) XOR b(6);
	b(14)<= b(7) XOR b(5);
	b(15)<= b(11) XOR b(5);
	b(16)<= b(12) XOR b(5);
	b(17)<= b(6) XOR b(4);
	b(18)<= b(14) XOR b(4);
	b(19)<= b(15) XOR b(4);
	b(20)<= b(5) XOR b(10);
	b(21)<= b(17) XOR b(10);
	b(22)<= b(18) XOR b(10);
	b(23)<= b(4) XOR b(13);
	b(24)<= b(20) XOR b(13);
	b(25)<= b(21) XOR b(13);
	b(26)<= b(10) XOR b(16);
	b(27)<= b(23) XOR b(16);
	b(28)<= b(24) XOR b(16);
	c0<= b(0) & b(7) & b(6) & b(5) & b(4) & b(10) & b(13) & b(16);
	m0: dsdbm
		PORT MAP (din2, c0, dout(0));
	c1<= b(1) & b(0) & b(7) & b(6) & b(5) & b(4) & b(10) & b(13);
	m1: dsdbm
		PORT MAP (din2, c1, dout(1));
	c2<= b(2) & b(8) & b(11) & b(14) & b(17) & b(20) & b(23) & b(26);
	m2: dsdbm
		PORT MAP (din2, c2, dout(2));
	c3<= b(3) & b(9) & b(12) & b(15) & b(18) & b(21) & b(24) & b(27);
	m3: dsdbm
		PORT MAP (din2, c3, dout(3));
	c4<= b(4) & b(10) & b(13) & b(16) & b(19) & b(22) & b(25) & b(28);
	m4: dsdbm
		PORT MAP (din2, c4, dout(4));
	c5<= b(5) & b(4) & b(10) & b(13) & b(16) & b(19) & b(22) & b(25);
	m5: dsdbm
		PORT MAP (din2, c5, dout(5));
	c6<= b(6) & b(5) & b(4) & b(10) & b(13) & b(16) & b(19) & b(22);
	m6: dsdbm
		PORT MAP (din2, c6, dout(6));
	c7<= b(7) & b(6) & b(5) & b(4) & b(10) & b(13) & b(16) & b(19);
	m7: dsdbm
		PORT MAP (din2, c7, dout(7));

END dpma;

----------------------------------------------------------------------------------
-- Bit-Serial Standard Basis Multiplier for syn*c=dr module2 - ring

	USE WORK.const.ALL;
ENTITY dssbm IS
PORT (clk, ce, pe : IN BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dssbm;

ARCHITECTURE dssbma OF dssbm IS
	SIGNAL ring: BIT_VECTOR(0 TO m-1);
  BEGIN
	dout<= ring;
  PROCESS BEGIN
      WAIT UNTIL clk'EVENT AND clk='1';
      IF pe='1' THEN
	ring<= din;
      ELSIF ce='1' THEN
	ring(0)<= din(0) XOR (NOT pe AND ring(m-1));
	ring(1)<= din(1) XOR (NOT pe AND ring(0));
	ring(2)<= din(2) XOR (NOT pe AND (ring(m-1) XOR ring(1)));
	ring(3)<= din(3) XOR (NOT pe AND (ring(m-1) XOR ring(2)));
	ring(4)<= din(4) XOR (NOT pe AND (ring(m-1) XOR ring(3)));
	ring(5)<= din(5) XOR (NOT pe AND ring(4));
	ring(6)<= din(6) XOR (NOT pe AND ring(5));
	ring(7)<= din(7) XOR (NOT pe AND ring(6));
      END IF;
  END PROCESS;
END dssbma;

-------------------------------------------------------------------
-- sum t* XOR - dout= din(0) xor din(1) .... xor din(t)

	USE WORK.const.ALL;
ENTITY dxort IS
PORT (din0, din1, din2, din3, din4, din5, din6, din7, din8, din9, din10, din11: IN BIT;
	dout: OUT BIT);
END dxort;

ARCHITECTURE dxorta OF dxort IS
  BEGIN
	dout<= din0 XOR din1 XOR din2 XOR din3 XOR din4 XOR din5 XOR din6 XOR din7 XOR din8 XOR din9 XOR din10 XOR din11;
END dxorta;


--------------------------------------------------------------------

-- Multiply by L^i, where gen. polynomial = 1+ x^i + x^m (for m!=8)

	USE WORK.const.ALL;
ENTITY dmli IS
PORT (din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dmli;

ARCHITECTURE dmlia OF dmli IS
BEGIN
	dout(0)<= din(1);
	dout(1)<= din(2);
	dout(2)<= din(3);
	dout(3)<= din(4);
	dout(4)<= din(5);
	dout(5)<= din(6);
	dout(6)<= din(7);
	dout(7)<= din(0) XOR din(2) XOR din(3) XOR din(4);
END dmlia;

---------------------------------------------------------------------------
-- squaring dout<= (din)^2 in standard basis -- for inverse calculator

	USE WORK.const.ALL;
ENTITY dsq IS
PORT ( din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1)); -- serial output
END dsq;

ARCHITECTURE dsqa OF dsq IS
	SIGNAL dxor: BIT_VECTOR(0 TO 8);
  BEGIN
	dxor(0 TO m-1)<= din;
	dxor(8)<= dxor(4) XOR dxor(6); -- 2
		-- optimization saving = 2 XOR gates
	dout(0)<= dxor(0) XOR dxor(7) XOR dxor(8);
	dout(1)<= dxor(7);
	dout(2)<= dxor(1) XOR dxor(5) XOR dxor(8);
	dout(3)<= dxor(8);
	dout(4)<= dxor(2) XOR dxor(4) XOR dxor(5) XOR dxor(7);
	dout(5)<= dxor(5);
	dout(6)<= dxor(3) XOR dxor(5) XOR dxor(6);
	dout(7)<= dxor(6);
	-- no. XOR gates = 10

END dsqa;

-----------------------------------------------------------------------------
-- m* registers with reset to dual basis one

	USE WORK.const.ALL;
ENTITY drdrDualOne IS
PORT (clk, ce, reset: BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1)); -- serial output
END drdrDualOne;

ARCHITECTURE drdrDualOnea OF drdrDualOne IS
	SIGNAL q: BIT_VECTOR(0 TO m-1);
  BEGIN
	dout<= q;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF reset='1' THEN
		q<= "10100000";
	ELSIF ce='1' THEN
		q<= din;
	ELSE
		q<= q;
	END IF;
  END PROCESS;
END drdrDualOnea;

----------------------------------------------------------------------------------
-- Inverter dout<= din^(-1)<= din^(2)*din^(4)*...*din^(2^(m-1))

	USE WORK.const.ALL;
ENTITY dinv IS
PORT (clk, cbBeg, bsel, caLast, cce, drnzero, snce, synpe: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1); --input data selected by sel_in
	dout: OUT BIT_VECTOR(0 TO m-1));
END dinv;

ARCHITECTURE dinva OF dinv IS
	SIGNAL qsq, sq, msin, mdin, mout: BIT_VECTOR(0 TO m-1);
	-- sq- square, q??- RD out, m??? - parallel multiplier, ?d/s -dual standard basis
	SIGNAL ce1, ce2a, ce2b, ce2, reset, sel: BIT;

	COMPONENT dmul21   -- 2-1 multiplexer
		PORT ( sel: IN BIT; d0, d1: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dmul21 USE ENTITY WORK.dmul21 (dmul21a);
	COMPONENT drdce     -- PIPO register
		PORT (clk, ce: IN BIT; din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: drdce USE ENTITY WORK.drdce (drdcea);
	COMPONENT drdrDualOne -- registers with and reset to dual basis one
		PORT (clk, ce, reset: IN BIT; din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: drdrDualOne USE ENTITY WORK.drdrDualOne (drdrDualOnea);
	COMPONENT dsq    -- dout<= (din)^2
		PORT ( din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dsq USE ENTITY WORK.dsq (dsqa);
	COMPONENT dpdbm    -- Parallel dual basis multiplier
		PORT (ddin, dsin: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dpdbm USE ENTITY WORK.dpdbm (dpdbma);
  BEGIN
	ce1<= ce2 OR caLast OR synpe;
	ce2a<= drnzero AND cbBeg;
	ce2b<= bsel OR ce2a;
	ce2<= cce AND NOT snce AND ce2b;
	reset<= (snce AND bsel) OR synpe;
	sel<= caLast OR synpe;

	dout<= mout;
	x1: dmul21
	  PORT MAP (sel, qsq, din, msin);
	s1: dsq
	  PORT MAP (msin, sq);
	q1: drdce
	  PORT MAP (clk, ce1, sq, qsq);
	q2: drdrDualOne
	  PORT MAP (clk, ce2, reset, mout, mdin);
	m1: dpdbm
	  PORT MAP (mdin, msin, mout);
END dinva;

---------------------------------------------------------------------------------
-- Find if chien search circuit is equal 0

	USE WORK.const.ALL;
ENTITY dcheq IS
PORT (din1, din2, din3, din4, din5, din6, din7, din8, din9, din10, din11: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT); -- dout=1 if equal
END dcheq;

ARCHITECTURE dcheqa OF dcheq IS
	SIGNAL eq: BIT_VECTOR(0 TO m-1);
  BEGIN
	eq(0)<= NOT din1(0) XOR din2(0) XOR din3(0) XOR din4(0) XOR din5(0) XOR din6(0) XOR din7(0) XOR din8(0) XOR din9(0) XOR din10(0) XOR din11(0);
	eq(1)<= din1(1) XOR din2(1) XOR din3(1) XOR din4(1) XOR din5(1) XOR din6(1) XOR din7(1) XOR din8(1) XOR din9(1) XOR din10(1) XOR din11(1);
	eq(2)<= din1(2) XOR din2(2) XOR din3(2) XOR din4(2) XOR din5(2) XOR din6(2) XOR din7(2) XOR din8(2) XOR din9(2) XOR din10(2) XOR din11(2);
	eq(3)<= din1(3) XOR din2(3) XOR din3(3) XOR din4(3) XOR din5(3) XOR din6(3) XOR din7(3) XOR din8(3) XOR din9(3) XOR din10(3) XOR din11(3);
	eq(4)<= din1(4) XOR din2(4) XOR din3(4) XOR din4(4) XOR din5(4) XOR din6(4) XOR din7(4) XOR din8(4) XOR din9(4) XOR din10(4) XOR din11(4);
	eq(5)<= din1(5) XOR din2(5) XOR din3(5) XOR din4(5) XOR din5(5) XOR din6(5) XOR din7(5) XOR din8(5) XOR din9(5) XOR din10(5) XOR din11(5);
	eq(6)<= din1(6) XOR din2(6) XOR din3(6) XOR din4(6) XOR din5(6) XOR din6(6) XOR din7(6) XOR din8(6) XOR din9(6) XOR din10(6) XOR din11(6);
	eq(7)<= din1(7) XOR din2(7) XOR din3(7) XOR din4(7) XOR din5(7) XOR din6(7) XOR din7(7) XOR din8(7) XOR din9(7) XOR din10(7) XOR din11(7);
	dout<= NOT (eq(0) OR eq(1) OR eq(2) OR eq(3) OR eq(4) OR eq(5) OR eq(6) OR eq(7));
END dcheqa;

----------------------------------------------------------------------------------
---------------------------------------------------------------------------
-- Syndromes calculation circuits

	USE WORK.const.ALL;
ENTITY dsyn1 IS
PORT (clk, pe ,din: IN BIT;
	dout1, dout2, dout4, dout8, dout16: OUT BIT_VECTOR(0 TO m-1));
END dsyn1;

ARCHITECTURE dsyn1a OF dsyn1 IS
	SIGNAL syn: BIT_VECTOR(0 TO 19);
  BEGIN
	syn(8)<= syn(5) XOR syn(6); -- 10
	syn(9)<= syn(3) XOR syn(4); -- 9
	syn(10)<= syn(2) XOR syn(7); -- 8
	syn(11)<= syn(1) XOR syn(9); -- 4
	syn(12)<= syn(4) XOR syn(8); -- 3
	syn(13)<= syn(3) XOR syn(8); -- 2
	syn(14)<= syn(5) XOR syn(10); -- 2
	syn(15)<= syn(0) XOR syn(6); -- 1
	syn(16)<= syn(1) XOR syn(7); -- 1
	syn(17)<= syn(1) XOR syn(12); -- 1
	syn(18)<= syn(6) XOR syn(10); -- 1
	syn(19)<= syn(8) XOR syn(10); -- 1
		-- Saving due to optimization = 43
	dout1(0 TO m-1)<= syn(0 TO m-1);
	dout2(0)<= syn(4) XOR syn(7) XOR syn(15);
	dout2(1)<= syn(7);
	dout2(2)<= syn(17);
	dout2(3)<= syn(4) XOR syn(6);
	dout2(4)<= syn(4) XOR syn(14);
	dout2(5)<= syn(5);
	dout2(6)<= syn(13);
	dout2(7)<= syn(6);
	dout4(0)<= syn(2) XOR syn(3) XOR syn(15);
	dout4(1)<= syn(6);
	dout4(2)<= syn(2) XOR syn(8) XOR syn(9);
	dout4(3)<= syn(9) XOR syn(18);
	dout4(4)<= syn(1) XOR syn(14);
	dout4(5)<= syn(5);
	dout4(6)<= syn(9);
	dout4(7)<= syn(13);
	dout8(0)<= syn(0) XOR syn(7) XOR syn(11);
	dout8(1)<= syn(13);
	dout8(2)<= syn(11) XOR syn(18);
	dout8(3)<= syn(11) XOR syn(14);
	dout8(4)<= syn(4) XOR syn(16);
	dout8(5)<= syn(5);
	dout8(6)<= syn(19);
	dout8(7)<= syn(9);
	dout16(0)<= syn(0) XOR syn(10) XOR syn(12);
	dout16(1)<= syn(9);
	dout16(2)<= syn(2) XOR syn(5) XOR syn(11);
	dout16(3)<= syn(2) XOR syn(17);
	dout16(4)<= syn(2) XOR syn(12);
	dout16(5)<= syn(5);
	dout16(6)<= syn(8) XOR syn(11);
	dout16(7)<= syn(19);
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  syn(0)<= din;
	  syn(1 TO 7)<= "0000000";
	ELSE
	  syn(0)<= syn(7) XOR din;
	  syn(1)<= syn(0);
	  syn(2)<= syn(16);
	  syn(3)<= syn(10);
	  syn(4)<= syn(3) XOR syn(7);
	  syn(5)<= syn(4);
	  syn(6)<= syn(5);
	  syn(7)<= syn(6);
	END IF;
  END PROCESS;
END dsyn1a;


	USE WORK.const.ALL;
ENTITY dsyn3 IS
PORT (clk, pe ,din: IN BIT;
	dout3, dout6, dout12: OUT BIT_VECTOR(0 TO m-1));
END dsyn3;

ARCHITECTURE dsyn3a OF dsyn3 IS
	SIGNAL syn: BIT_VECTOR(0 TO 18);
  BEGIN
	syn(8)<= syn(4) XOR syn(7); -- 8
	syn(9)<= syn(3) XOR syn(6); -- 7
	syn(10)<= syn(5) XOR syn(7); -- 5
	syn(11)<= syn(1) XOR syn(2); -- 4
	syn(12)<= syn(2) XOR syn(8); -- 4
	syn(13)<= syn(9) XOR syn(10); -- 3
	syn(14)<= syn(6) XOR syn(8); -- 2
	syn(15)<= syn(3) XOR syn(7); -- 1
	syn(16)<= syn(4) XOR syn(9); -- 1
	syn(17)<= syn(5) XOR syn(11); -- 1
	syn(18)<= syn(9) XOR syn(12); -- 1
		-- Saving due to optimization = 37
	dout3(0)<= syn(0) XOR syn(14);
	dout3(1)<= syn(3) XOR syn(5);
	dout3(2)<= syn(5) XOR syn(14);
	dout3(3)<= syn(1) XOR syn(16);
	dout3(4)<= syn(15);
	dout3(5)<= syn(13);
	dout3(6)<= syn(12);
	dout3(7)<= syn(4);
	dout6(0)<= syn(0) XOR syn(18);
	dout6(1)<= syn(4);
	dout6(2)<= syn(18);
	dout6(3)<= syn(2) XOR syn(3) XOR syn(4);
	dout6(4)<= syn(7);
	dout6(5)<= syn(13);
	dout6(6)<= syn(17);
	dout6(7)<= syn(12);
	dout12(0)<= syn(0) XOR syn(11) XOR syn(13);
	dout12(1)<= syn(12);
	dout12(2)<= syn(11) XOR syn(16);
	dout12(3)<= syn(10) XOR syn(11);
	dout12(4)<= syn(5);
	dout12(5)<= syn(13);
	dout12(6)<= syn(1) XOR syn(14);
	dout12(7)<= syn(17);
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  syn(0)<= din;
	  syn(1 TO 7)<= "0000000";
	ELSE
	  syn(0)<= syn(7) XOR din;
	  syn(1)<= syn(0) XOR syn(7);
	  syn(2)<= syn(1) XOR syn(7);
	  syn(3)<= syn(2);
	  syn(4)<= syn(15);
	  syn(5)<= syn(8);
	  syn(6)<= syn(10);
	  syn(7)<= syn(6);
	END IF;
  END PROCESS;
END dsyn3a;


	USE WORK.const.ALL;
ENTITY dsyn5 IS
PORT (clk, pe ,din: IN BIT;
	dout5, dout10, dout20: OUT BIT_VECTOR(0 TO m-1));
END dsyn5;

ARCHITECTURE dsyn5a OF dsyn5 IS
	SIGNAL syn: BIT_VECTOR(0 TO 16);
  BEGIN
	syn(8)<= syn(3) XOR syn(4); -- 8
	syn(9)<= syn(2) XOR syn(6); -- 7
	syn(10)<= syn(1) XOR syn(8); -- 5
	syn(11)<= syn(4) XOR syn(7); -- 5
	syn(12)<= syn(0) XOR syn(5); -- 2
	syn(13)<= syn(9) XOR syn(10); -- 2
	syn(14)<= syn(1) XOR syn(7); -- 1
	syn(15)<= syn(6) XOR syn(12); -- 1
	syn(16)<= syn(7) XOR syn(10); -- 1
		-- Saving due to optimization = 32
	dout5(0)<= syn(12);
	dout5(1)<= syn(3) XOR syn(5);
	dout5(2)<= syn(2) XOR syn(7) XOR syn(8);
	dout5(3)<= syn(7);
	dout5(4)<= syn(2) XOR syn(11);
	dout5(5)<= syn(13);
	dout5(6)<= syn(9);
	dout5(7)<= syn(11);
	dout10(0)<= syn(15);
	dout10(1)<= syn(11);
	dout10(2)<= syn(2) XOR syn(5) XOR syn(14);
	dout10(3)<= syn(6) XOR syn(11);
	dout10(4)<= syn(9) XOR syn(14);
	dout10(5)<= syn(13);
	dout10(6)<= syn(16);
	dout10(7)<= syn(9);
	dout20(0)<= syn(8) XOR syn(15);
	dout20(1)<= syn(9);
	dout20(2)<= syn(1) XOR syn(11);
	dout20(3)<= syn(8) XOR syn(9);
	dout20(4)<= syn(5) XOR syn(6) XOR syn(10);
	dout20(5)<= syn(13);
	dout20(6)<= syn(2) XOR syn(4);
	dout20(7)<= syn(16);
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  syn(0)<= din;
	  syn(1 TO 7)<= "0000000";
	ELSE
	  syn(0)<= syn(7) XOR din;
	  syn(1)<= syn(0) XOR syn(7);
	  syn(2)<= syn(1);
	  syn(3)<= syn(2);
	  syn(4)<= syn(3) XOR syn(7);
	  syn(5)<= syn(11);
	  syn(6)<= syn(5) XOR syn(7);
	  syn(7)<= syn(6) XOR syn(7);
	END IF;
  END PROCESS;
END dsyn5a;


	USE WORK.const.ALL;
ENTITY dsyn7 IS
PORT (clk, pe ,din: IN BIT;
	dout7, dout14: OUT BIT_VECTOR(0 TO m-1));
END dsyn7;

ARCHITECTURE dsyn7a OF dsyn7 IS
	SIGNAL syn: BIT_VECTOR(0 TO 16);
  BEGIN
	syn(8)<= syn(3) XOR syn(6); -- 5
	syn(9)<= syn(4) XOR syn(5); -- 5
	syn(10)<= syn(5) XOR syn(7); -- 3
	syn(11)<= syn(2) XOR syn(9); -- 2
	syn(12)<= syn(0) XOR syn(8); -- 1
	syn(13)<= syn(1) XOR syn(6); -- 1
	syn(14)<= syn(4) XOR syn(7); -- 1
	syn(15)<= syn(7) XOR syn(9); -- 1
	syn(16)<= syn(10) XOR syn(13); -- 1
		-- Saving due to optimization = 20
	dout7(0)<= syn(2) XOR syn(12);
	dout7(1)<= syn(2);
	dout7(2)<= syn(8) XOR syn(10);
	dout7(3)<= syn(15);
	dout7(4)<= syn(8) XOR syn(11);
	dout7(5)<= syn(8);
	dout7(6)<= syn(3);
	dout7(7)<= syn(16);
	dout14(0)<= syn(1) XOR syn(12) XOR syn(14);
	dout14(1)<= syn(16);
	dout14(2)<= syn(3) XOR syn(9);
	dout14(3)<= syn(6) XOR syn(11);
	dout14(4)<= syn(1) XOR syn(3) XOR syn(11);
	dout14(5)<= syn(8);
	dout14(6)<= syn(6) XOR syn(15);
	dout14(7)<= syn(3);
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  syn(0)<= din;
	  syn(1 TO 7)<= "0000000";
	ELSE
	  syn(0)<= syn(7) XOR din;
	  syn(1)<= syn(0);
	  syn(2)<= syn(1);
	  syn(3)<= syn(2) XOR syn(7);
	  syn(4)<= syn(3);
	  syn(5)<= syn(14);
	  syn(6)<= syn(10);
	  syn(7)<= syn(6);
	END IF;
  END PROCESS;
END dsyn7a;


	USE WORK.const.ALL;
ENTITY dsyn9 IS
PORT (clk, pe ,din: IN BIT;
	dout9, dout18: OUT BIT_VECTOR(0 TO m-1));
END dsyn9;

ARCHITECTURE dsyn9a OF dsyn9 IS
	SIGNAL syn: BIT_VECTOR(0 TO 12);
  BEGIN
	syn(8)<= syn(2) XOR syn(4); -- 5
	syn(9)<= syn(5) XOR syn(7); -- 4
	syn(10)<= syn(1) XOR syn(8); -- 3
	syn(11)<= syn(5) XOR syn(6); -- 2
	syn(12)<= syn(7) XOR syn(10); -- 1
		-- Saving due to optimization = 15
	dout9(0)<= syn(0) XOR syn(8) XOR syn(9);
	dout9(1)<= syn(1);
	dout9(2)<= syn(3) XOR syn(8);
	dout9(3)<= syn(1) XOR syn(2) XOR syn(3);
	dout9(4)<= syn(1) XOR syn(6);
	dout9(5)<= syn(12);
	dout9(6)<= syn(11);
	dout9(7)<= syn(9);
	dout18(0)<= syn(0) XOR syn(5) XOR syn(10);
	dout18(1)<= syn(9);
	dout18(2)<= syn(9) XOR syn(10);
	dout18(3)<= syn(1) XOR syn(5);
	dout18(4)<= syn(3) XOR syn(11);
	dout18(5)<= syn(12);
	dout18(6)<= syn(3) XOR syn(4) XOR syn(6) XOR syn(9);
	dout18(7)<= syn(11);
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  syn(0)<= din;
	  syn(1 TO 7)<= "0000000";
	ELSE
	  syn(0)<= syn(7) XOR din;
	  syn(1)<= syn(0);
	  syn(2)<= syn(1) XOR syn(7);
	  syn(3)<= syn(2) XOR syn(7);
	  syn(4)<= syn(3) XOR syn(7);
	  syn(5)<= syn(4) XOR syn(7);
	  syn(6)<= syn(5);
	  syn(7)<= syn(6) XOR syn(7);
	END IF;
  END PROCESS;
END dsyn9a;


	USE WORK.const.ALL;
ENTITY dsyn11 IS
PORT (clk, pe ,din: IN BIT;
	dout11: OUT BIT_VECTOR(0 TO m-1));
END dsyn11;

ARCHITECTURE dsyn11a OF dsyn11 IS
	SIGNAL syn: BIT_VECTOR(0 TO 7);
  BEGIN
	dout11<= syn;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  syn(0)<= din;
	  syn(1 TO 7)<= "0000000";
	ELSE
	syn(0)<= din XOR syn(1) XOR syn(2) XOR syn(3) XOR syn(7);
	syn(1)<= syn(2) XOR syn(3) XOR syn(4);
	syn(2)<= syn(1) XOR syn(2) XOR syn(4) XOR syn(5) XOR syn(7);
	syn(3)<= syn(0) XOR syn(1) XOR syn(5) XOR syn(6) XOR syn(7);
	syn(4)<= syn(3) XOR syn(6);
	syn(5)<= syn(0) XOR syn(4) XOR syn(7);
	syn(6)<= syn(0) XOR syn(1) XOR syn(5);
	syn(7)<= syn(0) XOR syn(1) XOR syn(2) XOR syn(6);
	END IF;
  END PROCESS;
END dsyn11a;


	USE WORK.const.ALL;
ENTITY dsyn13 IS
PORT (clk, pe ,din: IN BIT;
	dout13: OUT BIT_VECTOR(0 TO m-1));
END dsyn13;

ARCHITECTURE dsyn13a OF dsyn13 IS
	SIGNAL syn: BIT_VECTOR(0 TO 7);
  BEGIN
	dout13<= syn;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  syn(0)<= din;
	  syn(1 TO 7)<= "0000000";
	ELSE
	syn(0)<= din XOR syn(0) XOR syn(1) XOR syn(5);
	syn(1)<= syn(0) XOR syn(1) XOR syn(2) XOR syn(6);
	syn(2)<= syn(0) XOR syn(2) XOR syn(3) XOR syn(5) XOR syn(7);
	syn(3)<= syn(3) XOR syn(4) XOR syn(5) XOR syn(6);
	syn(4)<= syn(1) XOR syn(4) XOR syn(6) XOR syn(7);
	syn(5)<= syn(2) XOR syn(5) XOR syn(7);
	syn(6)<= syn(3) XOR syn(6);
	syn(7)<= syn(0) XOR syn(4) XOR syn(7);
	END IF;
  END PROCESS;
END dsyn13a;


	USE WORK.const.ALL;
ENTITY dsyn15 IS
PORT (clk, pe ,din: IN BIT;
	dout15: OUT BIT_VECTOR(0 TO m-1));
END dsyn15;

ARCHITECTURE dsyn15a OF dsyn15 IS
	SIGNAL syn: BIT_VECTOR(0 TO 7);
  BEGIN
	dout15<= syn;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  syn(0)<= din;
	  syn(1 TO 7)<= "0000000";
	ELSE
	syn(0)<= din XOR syn(3) XOR syn(6);
	syn(1)<= syn(0) XOR syn(4) XOR syn(7);
	syn(2)<= syn(0) XOR syn(1) XOR syn(3) XOR syn(5) XOR syn(6);
	syn(3)<= syn(1) XOR syn(2) XOR syn(3) XOR syn(4) XOR syn(7);
	syn(4)<= syn(2) XOR syn(4) XOR syn(5) XOR syn(6);
	syn(5)<= syn(0) XOR syn(3) XOR syn(5) XOR syn(6) XOR syn(7);
	syn(6)<= syn(1) XOR syn(4) XOR syn(6) XOR syn(7);
	syn(7)<= syn(2) XOR syn(5) XOR syn(7);
	END IF;
  END PROCESS;
END dsyn15a;


	USE WORK.const.ALL;
ENTITY dsyn17 IS
PORT (clk, pe ,din: IN BIT;
	dout17: OUT BIT_VECTOR(0 TO m-1));
END dsyn17;

ARCHITECTURE dsyn17a OF dsyn17 IS
	SIGNAL syn: BIT_VECTOR(0 TO 4);
  BEGIN
	syn(4)<= syn(2) XOR syn(3); -- 1
		-- Saving due to optimization = 1
	dout17(0)<= syn(0);
	dout17(1)<= syn(4);
	dout17(2)<= syn(2);
	dout17(3)<= syn(1) XOR syn(4);
	dout17(4)<= syn(1);
	dout17(5)<= '0';
	dout17(6)<= syn(2);
	dout17(7)<= syn(1);
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  syn(0)<= din;
	  syn(1 TO 3)<= "000";
	ELSE
	  syn(0)<= syn(3) XOR din;
	  syn(1)<= syn(0) XOR syn(3);
	  syn(2)<= syn(1);
	  syn(3)<= syn(2);
	END IF;
  END PROCESS;
END dsyn17a;


	USE WORK.const.ALL;
ENTITY dsyn19 IS
PORT (clk, pe ,din: IN BIT;
	dout19: OUT BIT_VECTOR(0 TO m-1));
END dsyn19;

ARCHITECTURE dsyn19a OF dsyn19 IS
	SIGNAL syn: BIT_VECTOR(0 TO 7);
  BEGIN
	dout19<= syn;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  syn(0)<= din;
	  syn(1 TO 7)<= "0000000";
	ELSE
	syn(0)<= din XOR syn(2) XOR syn(4) XOR syn(5) XOR syn(6);
	syn(1)<= syn(0) XOR syn(3) XOR syn(5) XOR syn(6) XOR syn(7);
	syn(2)<= syn(1) XOR syn(2) XOR syn(5) XOR syn(7);
	syn(3)<= syn(0) XOR syn(3) XOR syn(4) XOR syn(5);
	syn(4)<= syn(0) XOR syn(1) XOR syn(2);
	syn(5)<= syn(1) XOR syn(2) XOR syn(3);
	syn(6)<= syn(0) XOR syn(2) XOR syn(3) XOR syn(4);
	syn(7)<= syn(1) XOR syn(3) XOR syn(4) XOR syn(5);
	END IF;
  END PROCESS;
END dsyn19a;


	USE WORK.const.ALL;
ENTITY dsyn21 IS
PORT (clk, pe ,din: IN BIT;
	dout21: OUT BIT_VECTOR(0 TO m-1));
END dsyn21;

ARCHITECTURE dsyn21a OF dsyn21 IS
	SIGNAL syn: BIT_VECTOR(0 TO 7);
  BEGIN
	dout21<= syn;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  syn(0)<= din;
	  syn(1 TO 7)<= "0000000";
	ELSE
	syn(0)<= din XOR syn(0) XOR syn(2) XOR syn(3) XOR syn(4);
	syn(1)<= syn(1) XOR syn(3) XOR syn(4) XOR syn(5);
	syn(2)<= syn(0) XOR syn(3) XOR syn(5) XOR syn(6);
	syn(3)<= syn(1) XOR syn(2) XOR syn(3) XOR syn(6) XOR syn(7);
	syn(4)<= syn(0) XOR syn(7);
	syn(5)<= syn(0) XOR syn(1);
	syn(6)<= syn(0) XOR syn(1) XOR syn(2);
	syn(7)<= syn(1) XOR syn(2) XOR syn(3);
	END IF;
  END PROCESS;
END dsyn21a;


---------------------------------------------------------------------------
-- Chien search circuits

	USE WORK.const.ALL;
ENTITY dch1 IS
PORT (clk, pe: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dch1;

ARCHITECTURE dch1a OF dch1 IS
	SIGNAL chin: BIT_VECTOR(0 TO m-1); -- registers input
	SIGNAL ch: BIT_VECTOR(0 TO 7); -- ch registers and optimization
  BEGIN
	dout<= ch(0 TO m-1);
	chin(0)<= ch(7);
	chin(1)<= ch(0);
	chin(2)<= ch(1) XOR ch(7);
	chin(3)<= ch(2) XOR ch(7);
	chin(4)<= ch(3) XOR ch(7);
	chin(5)<= ch(4);
	chin(6)<= ch(5);
	chin(7)<= ch(6);
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  ch(0 TO m-1)<= din;
	ELSE
	  ch(0 TO m-1)<= chin;
	END IF;
  END PROCESS;
	-- number XOR gates= 3;
END dch1a;


	USE WORK.const.ALL;
ENTITY dch2 IS
PORT (clk, pe: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dch2;

ARCHITECTURE dch2a OF dch2 IS
	SIGNAL chin: BIT_VECTOR(0 TO m-1); -- registers input
	SIGNAL ch: BIT_VECTOR(0 TO 8); -- ch registers and optimization
  BEGIN
	dout<= ch(0 TO m-1);
	ch(8)<= ch(6) XOR ch(7); -- 1
		-- optimization saving = 1 XOR gates
	chin(0)<= ch(6);
	chin(1)<= ch(7);
	chin(2)<= ch(0) XOR ch(6);
	chin(3)<= ch(1) XOR ch(8);
	chin(4)<= ch(2) XOR ch(8);
	chin(5)<= ch(3) XOR ch(7);
	chin(6)<= ch(4);
	chin(7)<= ch(5);
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  ch(0 TO m-1)<= din;
	ELSE
	  ch(0 TO m-1)<= chin;
	END IF;
  END PROCESS;
	-- number XOR gates= 5;
END dch2a;


	USE WORK.const.ALL;
ENTITY dch3 IS
PORT (clk, pe: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dch3;

ARCHITECTURE dch3a OF dch3 IS
	SIGNAL chin: BIT_VECTOR(0 TO m-1); -- registers input
	SIGNAL ch: BIT_VECTOR(0 TO 8); -- ch registers and optimization
  BEGIN
	dout<= ch(0 TO m-1);
	ch(8)<= ch(5) XOR ch(6); -- 1
		-- optimization saving = 1 XOR gates
	chin(0)<= ch(5);
	chin(1)<= ch(6);
	chin(2)<= ch(5) XOR ch(7);
	chin(3)<= ch(0) XOR ch(8);
	chin(4)<= ch(1) XOR ch(7) XOR ch(8);
	chin(5)<= ch(2) XOR ch(6) XOR ch(7);
	chin(6)<= ch(3) XOR ch(7);
	chin(7)<= ch(4);
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  ch(0 TO m-1)<= din;
	ELSE
	  ch(0 TO m-1)<= chin;
	END IF;
  END PROCESS;
	-- number XOR gates= 8;
END dch3a;


	USE WORK.const.ALL;
ENTITY dch4 IS
PORT (clk, pe: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dch4;

ARCHITECTURE dch4a OF dch4 IS
	SIGNAL chin: BIT_VECTOR(0 TO m-1); -- registers input
	SIGNAL ch: BIT_VECTOR(0 TO 9); -- ch registers and optimization
  BEGIN
	dout<= ch(0 TO m-1);
	ch(8)<= ch(4) XOR ch(5); -- 1
	ch(9)<= ch(6) XOR ch(7); -- 1
		-- optimization saving = 2 XOR gates
	chin(0)<= ch(4);
	chin(1)<= ch(5);
	chin(2)<= ch(4) XOR ch(6);
	chin(3)<= ch(7) XOR ch(8);
	chin(4)<= ch(0) XOR ch(6) XOR ch(8);
	chin(5)<= ch(1) XOR ch(5) XOR ch(9);
	chin(6)<= ch(2) XOR ch(9);
	chin(7)<= ch(3) XOR ch(7);
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  ch(0 TO m-1)<= din;
	ELSE
	  ch(0 TO m-1)<= chin;
	END IF;
  END PROCESS;
	-- number XOR gates= 10;
END dch4a;


	USE WORK.const.ALL;
ENTITY dch5 IS
PORT (clk, pe: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dch5;

ARCHITECTURE dch5a OF dch5 IS
	SIGNAL chin: BIT_VECTOR(0 TO m-1); -- registers input
	SIGNAL ch: BIT_VECTOR(0 TO 10); -- ch registers and optimization
  BEGIN
	dout<= ch(0 TO m-1);
	ch(8)<= ch(3) XOR ch(7); -- 2
	ch(9)<= ch(4) XOR ch(5); -- 1
	ch(10)<= ch(6) XOR ch(7); -- 1
		-- optimization saving = 4 XOR gates
	chin(0)<= ch(8);
	chin(1)<= ch(4);
	chin(2)<= ch(5) XOR ch(8);
	chin(3)<= ch(4) XOR ch(6) XOR ch(8);
	chin(4)<= ch(3) XOR ch(9);
	chin(5)<= ch(0) XOR ch(6) XOR ch(9);
	chin(6)<= ch(1) XOR ch(5) XOR ch(10);
	chin(7)<= ch(2) XOR ch(10);
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  ch(0 TO m-1)<= din;
	ELSE
	  ch(0 TO m-1)<= chin;
	END IF;
  END PROCESS;
	-- number XOR gates= 13;
END dch5a;


	USE WORK.const.ALL;
ENTITY dch6 IS
PORT (clk, pe: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dch6;

ARCHITECTURE dch6a OF dch6 IS
	SIGNAL chin: BIT_VECTOR(0 TO m-1); -- registers input
	SIGNAL ch: BIT_VECTOR(0 TO 11); -- ch registers and optimization
  BEGIN
	dout<= ch(0 TO m-1);
	ch(8)<= ch(2) XOR ch(6); -- 2
	ch(9)<= ch(3) XOR ch(4); -- 1
	ch(10)<= ch(5) XOR ch(6); -- 1
	ch(11)<= ch(7) XOR ch(8); -- 1
		-- optimization saving = 5 XOR gates
	chin(0)<= ch(11);
	chin(1)<= ch(3) XOR ch(7);
	chin(2)<= ch(4) XOR ch(11);
	chin(3)<= ch(3) XOR ch(5) XOR ch(8);
	chin(4)<= ch(2) XOR ch(9);
	chin(5)<= ch(5) XOR ch(9);
	chin(6)<= ch(0) XOR ch(4) XOR ch(10);
	chin(7)<= ch(1) XOR ch(7) XOR ch(10);
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  ch(0 TO m-1)<= din;
	ELSE
	  ch(0 TO m-1)<= chin;
	END IF;
  END PROCESS;
	-- number XOR gates= 15;
END dch6a;


	USE WORK.const.ALL;
ENTITY dch7 IS
PORT (clk, pe: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dch7;

ARCHITECTURE dch7a OF dch7 IS
	SIGNAL chin: BIT_VECTOR(0 TO m-1); -- registers input
	SIGNAL ch: BIT_VECTOR(0 TO 11); -- ch registers and optimization
  BEGIN
	dout<= ch(0 TO m-1);
	ch(8)<= ch(1) XOR ch(5); -- 2
	ch(9)<= ch(2) XOR ch(3); -- 1
	ch(10)<= ch(4) XOR ch(5); -- 1
	ch(11)<= ch(6) XOR ch(7); -- 1
		-- optimization saving = 5 XOR gates
	chin(0)<= ch(8) XOR ch(11);
	chin(1)<= ch(2) XOR ch(11);
	chin(2)<= ch(3) XOR ch(6) XOR ch(8);
	chin(3)<= ch(2) XOR ch(4) XOR ch(8);
	chin(4)<= ch(1) XOR ch(7) XOR ch(9);
	chin(5)<= ch(4) XOR ch(9);
	chin(6)<= ch(3) XOR ch(10);
	chin(7)<= ch(0) XOR ch(6) XOR ch(10);
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  ch(0 TO m-1)<= din;
	ELSE
	  ch(0 TO m-1)<= chin;
	END IF;
  END PROCESS;
	-- number XOR gates= 17;
END dch7a;


	USE WORK.const.ALL;
ENTITY dch8 IS
PORT (clk, pe: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dch8;

ARCHITECTURE dch8a OF dch8 IS
	SIGNAL chin: BIT_VECTOR(0 TO m-1); -- registers input
	SIGNAL ch: BIT_VECTOR(0 TO 11); -- ch registers and optimization
  BEGIN
	dout<= ch(0 TO m-1);
	ch(8)<= ch(0) XOR ch(4); -- 2
	ch(9)<= ch(1) XOR ch(2); -- 1
	ch(10)<= ch(3) XOR ch(4); -- 1
	ch(11)<= ch(5) XOR ch(6); -- 1
		-- optimization saving = 5 XOR gates
	chin(0)<= ch(8) XOR ch(11);
	chin(1)<= ch(1) XOR ch(7) XOR ch(11);
	chin(2)<= ch(2) XOR ch(5) XOR ch(7) XOR ch(8);
	chin(3)<= ch(1) XOR ch(3) XOR ch(8);
	chin(4)<= ch(0) XOR ch(6) XOR ch(9);
	chin(5)<= ch(3) XOR ch(7) XOR ch(9);
	chin(6)<= ch(2) XOR ch(10);
	chin(7)<= ch(5) XOR ch(10);
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  ch(0 TO m-1)<= din;
	ELSE
	  ch(0 TO m-1)<= chin;
	END IF;
  END PROCESS;
	-- number XOR gates= 19;
END dch8a;


	USE WORK.const.ALL;
ENTITY dch9 IS
PORT (clk, pe: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dch9;

ARCHITECTURE dch9a OF dch9 IS
	SIGNAL chin: BIT_VECTOR(0 TO m-1); -- registers input
	SIGNAL ch: BIT_VECTOR(0 TO 11); -- ch registers and optimization
  BEGIN
	dout<= ch(0 TO m-1);
	ch(8)<= ch(2) XOR ch(3); -- 2
	ch(9)<= ch(0) XOR ch(1); -- 1
	ch(10)<= ch(1) XOR ch(7); -- 1
	ch(11)<= ch(3) XOR ch(4); -- 1
		-- optimization saving = 5 XOR gates
	chin(0)<= ch(5) XOR ch(11);
	chin(1)<= ch(0) XOR ch(4) XOR ch(5) XOR ch(6);
	chin(2)<= ch(6) XOR ch(10) XOR ch(11);
	chin(3)<= ch(0) XOR ch(7) XOR ch(8);
	chin(4)<= ch(5) XOR ch(9);
	chin(5)<= ch(2) XOR ch(6) XOR ch(9);
	chin(6)<= ch(8) XOR ch(10);
	chin(7)<= ch(4) XOR ch(8);
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  ch(0 TO m-1)<= din;
	ELSE
	  ch(0 TO m-1)<= chin;
	END IF;
  END PROCESS;
	-- number XOR gates= 18;
END dch9a;


	USE WORK.const.ALL;
ENTITY dch10 IS
PORT (clk, pe: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dch10;

ARCHITECTURE dch10a OF dch10 IS
	SIGNAL chin: BIT_VECTOR(0 TO m-1); -- registers input
	SIGNAL ch: BIT_VECTOR(0 TO 11); -- ch registers and optimization
  BEGIN
	dout<= ch(0 TO m-1);
	ch(8)<= ch(1) XOR ch(2); -- 2
	ch(9)<= ch(0) XOR ch(5); -- 1
	ch(10)<= ch(2) XOR ch(3); -- 1
	ch(11)<= ch(6) XOR ch(8); -- 1
		-- optimization saving = 5 XOR gates
	chin(0)<= ch(4) XOR ch(10);
	chin(1)<= ch(3) XOR ch(4) XOR ch(5);
	chin(2)<= ch(6) XOR ch(9) XOR ch(10);
	chin(3)<= ch(7) XOR ch(11);
	chin(4)<= ch(0) XOR ch(4) XOR ch(7);
	chin(5)<= ch(1) XOR ch(9);
	chin(6)<= ch(0) XOR ch(11);
	chin(7)<= ch(3) XOR ch(7) XOR ch(8);
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  ch(0 TO m-1)<= din;
	ELSE
	  ch(0 TO m-1)<= chin;
	END IF;
  END PROCESS;
	-- number XOR gates= 17;
END dch10a;


	USE WORK.const.ALL;
ENTITY dch11 IS
PORT (clk, pe: IN BIT;
	din: IN BIT_VECTOR(0 TO m-1);
	dout: OUT BIT_VECTOR(0 TO m-1));
END dch11;

ARCHITECTURE dch11a OF dch11 IS
	SIGNAL chin: BIT_VECTOR(0 TO m-1); -- registers input
	SIGNAL ch: BIT_VECTOR(0 TO 11); -- ch registers and optimization
  BEGIN
	dout<= ch(0 TO m-1);
	ch(8)<= ch(0) XOR ch(1); -- 2
	ch(9)<= ch(1) XOR ch(2); -- 1
	ch(10)<= ch(4) XOR ch(7); -- 1
	ch(11)<= ch(5) XOR ch(8); -- 1
		-- optimization saving = 5 XOR gates
	chin(0)<= ch(3) XOR ch(7) XOR ch(9);
	chin(1)<= ch(2) XOR ch(3) XOR ch(4);
	chin(2)<= ch(5) XOR ch(9) XOR ch(10);
	chin(3)<= ch(6) XOR ch(7) XOR ch(11);
	chin(4)<= ch(3) XOR ch(6);
	chin(5)<= ch(0) XOR ch(10);
	chin(6)<= ch(11);
	chin(7)<= ch(2) XOR ch(6) XOR ch(8);
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	IF pe='1' THEN
	  ch(0 TO m-1)<= din;
	ELSE
	  ch(0 TO m-1)<= chin;
	END IF;
  END PROCESS;
	-- number XOR gates= 17;
END dch11a;


-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-- CONTROL ENTITIES - counters
-- counter a

	USE WORK.const.ALL;
ENTITY dca IS
PORT (clk, reset: IN BIT;
	cRes: OUT BIT; -- cRes<= countLast OR  reset
	dout: OUT BIT_VECTOR(0 TO sizea-1)); -- count
END dca;

ARCHITECTURE dcaa OF dca IS
	SIGNAL ca, cin, cand: BIT_VECTOR(0 TO sizea-1);
	SIGNAL CRes1, cLast: BIT;
  BEGIN
	dout<= ca;
	cRes<= cRes1;
	cRes1<= cLast OR reset;
	cLast<= ca(0) AND NOT ca(1) AND NOT ca(2) AND ca(3);  -- ca= 9
		--cLast=1 - when c= iteration-1
	cand(0)<= ca(0);
	cin(0)<= NOT ca(0);

	   gen_cin:
	FOR i IN 1 TO sizea-1 GENERATE
		cin(i)<= cand(i-1) XOR ca(i);
	END GENERATE;
	  den_cand_if:
	IF sizea>2 GENERATE
	  gen_cand:
	  FOR i IN 1 TO sizea-2 GENERATE
		cand(i)<= ca(i) AND cand(i-1);
	  END GENERATE;
	END GENERATE;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	FOR i IN 0 TO sizea-1 LOOP
	  IF cRes1='1' THEN
		ca(i)<= '0';
	  ELSE
		ca(i)<= cin(i);
	  END IF;
	END LOOP;
  END PROCESS;
END dcaa;

------------------------------------------------------------------------------
-- counter b -- no. of cicles count= iteration*cb +ca

	USE WORK.const.ALL;
ENTITY dcb IS
PORT (clk, ce, reset: IN BIT;
	dout: OUT BIT_VECTOR(0 TO sizeb-1)); -- count
END dcb;

ARCHITECTURE dcba OF dcb IS
	SIGNAL cb, cin, cand: BIT_VECTOR(0 TO sizeb-1);
  BEGIN
	dout<= cb;
	cand(0)<= cb(0);
	cin(0)<= NOT cb(0);

	   gen_cin:
	FOR i IN 1 TO sizeb-1 GENERATE
		cin(i)<= cand(i-1) XOR cb(i);
	END GENERATE;
		gen_cand:
	FOR i IN 1 TO sizeb-2 GENERATE
		cand(i)<= cb(i) AND cand(i-1);
	END GENERATE;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	FOR i IN 0 TO sizeb-1 LOOP
	  IF reset='1' THEN
		cb(i)<= '0';
	  ELSIF ce='1' THEN
		cb(i)<= cin(i);
	  END IF;
	END LOOP;
  END PROCESS;
END dcba;
-------------------------------------------------------------------------------
-- l (degree of error polynomial in BMA) circuit

	USE WORK.const.ALL;
ENTITY dcl IS
PORT (clk, ce, reset, bsel: IN BIT;
	cb: BIT_VECTOR(0 TO sizeb-1);
	dout: OUT BIT); -- dout=1 if l<= cb
END dcl;

ARCHITECTURE dcla OF dcl IS
	SIGNAL l, lin, lcarry, lxor, lcomp: BIT_VECTOR(0 TO sizel-1);
	SIGNAL lce: BIT;
  BEGIN
	dout<= lcomp(sizel-1);
	-- compare --> lcomp(sizel-1)<= (cb>=l)
	lcomp(0)<= NOT l(0) OR cb(0);
	gencomp:
	FOR i IN 1 TO sizel-1 GENERATE
	  lcomp(i)<= (lcomp(i-1) AND (NOT l(i) OR cb(i)))  OR  (NOT l(i) AND cb(i));
	END GENERATE;

	-- register l subtractor; lin<= 2*cb-l+1 <=> { lin<=2*cb+2+NOT(l) }
	lin(0)<= NOT l(0);
	lin(1) <= cb(0) XOR l(1);
	lcarry(1)<= cb(0) OR NOT l(1);
	      genl:
	FOR i IN 2 TO sizel-1 GENERATE
		lxor(i)<= cb(i-1) XOR NOT l(i);
		lin(i)<= lxor(i) XOR lcarry(i-1);
		lcarry(i)<= (NOT l(i) AND cb(i-1)) OR (lxor(i) AND lcarry(i-1));
	END GENERATE;
	lce<= ce AND bsel;
  PROCESS BEGIN
	WAIT UNTIL clk'EVENT AND clk='1';
	-- l register
	IF reset='1' THEN
		l(0)<= bsel;   -- if Syn1=0 l<= 0, else l<=1
	ELSIF lce='1' THEN
		l(0)<= lin(0);
	END IF;

	FOR i IN 1 TO sizel-1 LOOP
	  IF reset='1' THEN
		l(i)<= '0';
	  ELSIF lce='1' THEN
		l(i)<= lin(i);
	  END IF;
	END LOOP;
  END PROCESS;
END dcla;

-------------------------------------------------------------------------------
-- control system and counter

	USE WORK.const.ALL;
ENTITY dcount IS
PORT (clk, reset, drnzero: IN BIT;
	bsel, bufCe, bufkCe, chpe, msmpe, snce, synpe, vdout, vdout1,c0first, cce, caLast1, cbBeg, ca3a, ca4a, ca5a: OUT BIT);
		-- vdout - delayed by one clock vdout11
END dcount;

ARCHITECTURE dcounta OF dcount IS
	COMPONENT drd1ce -- single register with clock enable
		PORT ( clk, ce, din: IN BIT; dout: OUT BIT);
		END COMPONENT;
		FOR ALL: drd1ce USE ENTITY WORK.drd1ce (drd1cea);
	COMPONENT dca  -- counter a
		PORT (clk, reset: IN BIT; cRes: OUT BIT;
		dout: OUT BIT_VECTOR(0 TO sizea-1));
		END COMPONENT;
		FOR ALL: dca USE ENTITY WORK.dca (dcaa);
	COMPONENT dcb  -- counter b
		PORT (clk, ce, reset: IN BIT;
		dout: OUT BIT_VECTOR(0 TO sizeb-1));
		END COMPONENT;
		FOR ALL: dcb USE ENTITY WORK.dcb (dcba);
	COMPONENT dcl -- l (degree of error polynomial in BMA) circuit
		PORT (clk, ce, reset, bsel: IN BIT; -- dout=1 if l<= cb
		cb: BIT_VECTOR(0 TO sizeb-1); dout: OUT BIT);
		END COMPONENT;
		FOR ALL: dcL USE ENTITY WORK.dcL (dcLa);
	SIGNAL cceR, cceS, cceSR, dringCe2, dringPe2: BIT;

	-- VHDL Template
	SIGNAL ca: BIT_VECTOR(0 TO sizea-1); -- counter a
	SIGNAL cb: BIT_VECTOR(0 TO sizeb-1); --  count= ca+ iteration*cb
	SIGNAL res, bsel1, caRes, bufR, bufRa, bufRb, bufS, bufSa, bufSb, bufSR: BIT;
	SIGNAL chpe1, chpe1a, chpe1b, synpe1,  msmpe1, cei1: BIT;
	-- cei - interleave clock enable
	SIGNAL vdout11, vdout11a, vdout1R, vdout1Ra, vdout1Rb: BIT;
	SIGNAL vdout1S, vdout1Sa, vdout1Sb: BIT;
	SIGNAL ca0, caLast,caNextLast, cb0, cLast, cLasta, cLastb, lCe, lcomp: BIT;
	SIGNAL bufkCeCe, one, vdout11Ce, vdout11In, bufCe1, bufkCe1: BIT;
	SIGNAL noFirstVdoutIn, noFirstVdout, vdout11aDel: BIT;
  BEGIN
	res<= reset OR clast;
	a1: dca
		PORT MAP (clk, res, caLast, ca);
	b1: dcb
		PORT MAP (clk, caLast, res, cb);
	l1: dcl
		PORT MAP (clk, lCe, synpe1, bsel1, cb, lcomp); -- lcomp=1 if cb>=l
	bufkCeCe<= res OR bufR;
	bufk_Ce: drd1ce  -- buffer Clock Enable register
		PORT MAP (clk, bufkCeCe, res, bufkCe1);
	bufkCe<= bufkCe1 AND cei1;

	one<= '1';
	vDoutD: drd1ce -- delay vdout by one clock signal: vdout11
		PORT MAP (clk, one, vdout11, vdout);
	vdout11Ce<= reset OR vdout1R OR vdout1S;
	vdout11In<= vdout1S AND NOT reset;
	vdout11P: drd1ce  -- set if vdout1S; reset if reset or vdout1R
		PORT MAP (clk, vdout11Ce, vdout11In, vdout11a);
	-- After reset the first vdout11a is not valid
	vdout1aDelay: drd1ce
		PORT MAP (clk, one, vdout11a, vdout11aDel);
	noFirstVdoutIn<= NOT reset AND ((NOT vdout11a AND vdout11aDel) OR noFirstVdout);
		-- falling edge of vdout1a - set; reset - reset
	noFirstAfterReset: drd1ce
		PORT MAP (clk, one, noFirstVdoutIn, noFirstVdout);

	vdout11<= vdout11a AND cei1 AND noFirstVdout;

	snce<= ca0;
	chpe<= chpe1;
	synpe<= synpe1;
	synpe1<= ca0 AND cb0;
	vdout1<= vdout11;
	msmpe<= msmpe1;
	bsel<= bsel1;
	bsel1<= drnzero AND (lcomp OR synpe1);

	-- generated by C program
	clastb<= cb(0) AND NOT cb(1) AND NOT cb(2) AND cb(3) AND cb(4);  -- cb= 25
	clasta<= NOT ca(0) AND NOT ca(1) AND ca(2) AND NOT ca(3);  -- ca= 4
	clast<= clasta AND clastb; -- count= 254
	chpe1b<= NOT cb(0) AND cb(1) AND NOT cb(2) AND cb(3) AND NOT cb(4);  -- cb= 10
	chpe1a<= NOT ca(0) AND NOT ca(1) AND NOT ca(2) AND ca(3);  -- ca= 8
	chpe1<= chpe1a AND chpe1b; -- count= 108
	vdout1Rb<= NOT cb(0) AND cb(1) AND NOT cb(2) AND NOT cb(3) AND NOT cb(4);  -- cb= 2
	vdout1Ra<= ca(0) AND NOT ca(1) AND ca(2) AND NOT ca(3);  -- ca= 5
	vdout1R<= vdout1Ra AND vdout1Rb; -- count= 25
	vdout1Sb<= NOT cb(0) AND cb(1) AND NOT cb(2) AND cb(3) AND NOT cb(4);  -- cb= 10
	vdout1Sa<= ca(0) AND NOT ca(1) AND NOT ca(2) AND ca(3);  -- ca= 9
	vdout1S<= vdout1Sa AND vdout1Sb; -- count= 109
	bufRb<= cb(0) AND NOT cb(1) AND NOT cb(2) AND NOT cb(3) AND cb(4);  -- cb= 17
	bufRa<= NOT ca(0) AND NOT ca(1) AND NOT ca(2) AND NOT ca(3);  -- ca= 0
	bufR<= bufRa AND bufRb; -- count= 170
	cb0<= NOT cb(0) AND NOT cb(1) AND NOT cb(2) AND NOT cb(3) AND NOT cb(4);  -- cb= 0
	lCe<= caLast AND NOT cb0;
	caLast1<= caLast;
	cceR<= ca(0) AND ca(1) AND ca(2) AND NOT ca(3);  -- ca= 7
	cceS<= caLast OR synpe1;
	cceSR<= cceS OR cceR;
	cceP: drd1ce
		PORT MAP(clk, cceSR, cceS, cce);
	cbBeg<= cb0;
	c0first<= caNextLast;
	ca3a<= ca(0) AND ca(1) AND NOT ca(2) AND NOT ca(3);  -- ca= 3
	ca4a<= NOT ca(0) AND NOT ca(1) AND ca(2) AND NOT ca(3);  -- ca= 4
	ca5a<= ca(0) AND NOT ca(1) AND ca(2) AND NOT ca(3);  -- ca= 5
	msmpe1<= ca(0) AND NOT ca(1) AND NOT ca(2) AND NOT ca(3);  -- ca= 1
	ca0<= NOT ca(0) AND NOT ca(1) AND NOT ca(2) AND NOT ca(3);  -- ca= 0
	caNextLast<= NOT ca(0) AND NOT ca(1) AND NOT ca(2) AND ca(3);  -- ca= 8
	bufCe<= '1';
	cei1<= '1';
END dcounta;


------------------------------------------------------------------------------
----------------------------------------------------------------------------------
-- decoder

	USE WORK.const.ALL;
ENTITY dec IS
PORT (clk, reset, din: IN BIT;
	vdout, dout: OUT BIT);
END dec;

ARCHITECTURE deca OF dec IS

	COMPONENT dbuf   -- input output buffer
		PORT (clk, bufCe, bufkCe, err, vdout1, din: IN BIT;
			dout: OUT BIT);
		END COMPONENT;
		FOR ALL: dbuf USE ENTITY WORK.dbuf (dbufa);
	COMPONENT drd1ce -- single register with clock enable
		PORT ( clk, ce, din: IN BIT; dout: OUT BIT);
		END COMPONENT;
		FOR ALL: drd1ce USE ENTITY WORK.drd1ce (drd1cea);
	COMPONENT dmul21
		PORT ( sel: IN BIT; d0, d1: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dmul21 USE ENTITY WORK.dmul21 (dmul21a);
	COMPONENT drd     -- PIPO register
		PORT (clk: IN BIT; din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: drd USE ENTITY WORK.drd (drda);
	COMPONENT drdce   -- PIPO register
		PORT (clk, ce: IN BIT; din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: drdce USE ENTITY WORK.drdce (drdcea);
	COMPONENT drdcer   -- PIPO register
		PORT (clk, ce, reset: IN BIT; din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: drdcer USE ENTITY WORK.drdcer (drdcera);
	COMPONENT drdcesone   -- m registers with CE and if set='1' dout<=din0&"00.."
		PORT ( clk, ce, set, dinone: IN BIT; din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: drdcesone USE ENTITY WORK.drdcesone (drdcesonea);
	COMPONENT dpm    -- Parallel dual basis multiplier
		PORT (din1, din2: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dpm USE ENTITY WORK.dpm (dpma);
	COMPONENT dxorm	    -- dout<= din1 xor din0; opt.1
		PORT (din0, din1: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dxorm USE ENTITY WORK.dxorm (dxorma);


		-- OPTION 3
	COMPONENT dshr   -- shift register with reset and serial XOR, opt.3
		PORT (clk, ce, reset, din: IN BIT;
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dshr USE ENTITY WORK.dshr (dshra);
	COMPONENT dshpe   -- shift register with parallel in and serial XOR, opt.3
		PORT (clk, ce, pe: IN BIT; din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dshpe USE ENTITY WORK.dshpe (dshpea);
	COMPONENT dsdbm -- serial dual basis multiplier without ring, opt.3
		PORT (dbin, sbin: IN BIT_VECTOR(0 TO m-1); dout: OUT BIT);
		END COMPONENT;
		FOR ALL: dsdbm USE ENTITY WORK.dsdbm (dsdbma);
	COMPONENT  dsdbmRing  -- serial dual basis multiplier ring, opt.3
		PORT (clk, pe: IN BIT;   -- pe- parallel enable
			din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dsdbmRing USE ENTITY WORK.dsdbmRing (dsdbmRinga);
	COMPONENT dssbm   -- serial standard basis multiplier ring, opt3
		PORT (clk, ce, pe: IN BIT; din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dssbm USE ENTITY WORK.dssbm (dssbma);
	COMPONENT dmli  -- multiply by alpha^i (1 + x^i + x^m; for m!=8), opt.3
		PORT (din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dmli USE ENTITY WORK.dmli (dmlia);
	COMPONENT dinv  -- inverter
		PORT (clk, cbBeg, bsel, caLast, cce, drnzero, snce, synpe: IN BIT;  -- pe- parallel enable - if dr!=0;
			din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dinv USE ENTITY WORK.dinv (dinva);
	COMPONENT dandm  -- dout<= din AND en
		PORT (en: IN BIT; din: IN BIT_VECTOR(0 TO m-1);
		dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dandm USE ENTITY WORK.dandm (dandma);

		-- common
	COMPONENT dxort		       -- (t-1) * XOR
		PORT (din0, din1, din2, din3, din4, din5, din6, din7, din8, din9, din10, din11: IN BIT; dout: OUT BIT);
		END COMPONENT;
		FOR ALL: dxort USE ENTITY WORK.dxort (dxorta);
	COMPONENT dcheq   -- check if Chien search circuit is zero
		PORT (din1, din2, din3, din4, din5, din6, din7, din8, din9, din10, din11: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT); -- dout=1 if an error occur
		END COMPONENT;
		FOR ALL: dcheq USE ENTITY WORK.dcheq (dcheqa);

	-- SYNDROMES & CHIEN SEARCH
	COMPONENT dsyn1
		PORT (clk, pe, din: IN BIT;
		dout1, dout2, dout4, dout8, dout16: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dsyn1 USE ENTITY WORK.dsyn1 (dsyn1a);
	COMPONENT dsyn3
		PORT (clk, pe, din: IN BIT;
		dout3, dout6, dout12: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dsyn3 USE ENTITY WORK.dsyn3 (dsyn3a);
	COMPONENT dsyn5
		PORT (clk, pe, din: IN BIT;
		dout5, dout10, dout20: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dsyn5 USE ENTITY WORK.dsyn5 (dsyn5a);
	COMPONENT dsyn7
		PORT (clk, pe, din: IN BIT;
		dout7, dout14: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dsyn7 USE ENTITY WORK.dsyn7 (dsyn7a);
	COMPONENT dsyn9
		PORT (clk, pe, din: IN BIT;
		dout9, dout18: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dsyn9 USE ENTITY WORK.dsyn9 (dsyn9a);
	COMPONENT dsyn11
		PORT (clk, pe, din: IN BIT;
		dout11: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dsyn11 USE ENTITY WORK.dsyn11 (dsyn11a);
	COMPONENT dsyn13
		PORT (clk, pe, din: IN BIT;
		dout13: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dsyn13 USE ENTITY WORK.dsyn13 (dsyn13a);
	COMPONENT dsyn15
		PORT (clk, pe, din: IN BIT;
		dout15: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dsyn15 USE ENTITY WORK.dsyn15 (dsyn15a);
	COMPONENT dsyn17
		PORT (clk, pe, din: IN BIT;
		dout17: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dsyn17 USE ENTITY WORK.dsyn17 (dsyn17a);
	COMPONENT dsyn19
		PORT (clk, pe, din: IN BIT;
		dout19: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dsyn19 USE ENTITY WORK.dsyn19 (dsyn19a);
	COMPONENT dsyn21
		PORT (clk, pe, din: IN BIT;
		dout21: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dsyn21 USE ENTITY WORK.dsyn21 (dsyn21a);
	COMPONENT dch1
		PORT (clk, pe: IN BIT; din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dch1 USE ENTITY WORK.dch1 (dch1a);
	COMPONENT dch2
		PORT (clk, pe: IN BIT; din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dch2 USE ENTITY WORK.dch2 (dch2a);
	COMPONENT dch3
		PORT (clk, pe: IN BIT; din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dch3 USE ENTITY WORK.dch3 (dch3a);
	COMPONENT dch4
		PORT (clk, pe: IN BIT; din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dch4 USE ENTITY WORK.dch4 (dch4a);
	COMPONENT dch5
		PORT (clk, pe: IN BIT; din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dch5 USE ENTITY WORK.dch5 (dch5a);
	COMPONENT dch6
		PORT (clk, pe: IN BIT; din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dch6 USE ENTITY WORK.dch6 (dch6a);
	COMPONENT dch7
		PORT (clk, pe: IN BIT; din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dch7 USE ENTITY WORK.dch7 (dch7a);
	COMPONENT dch8
		PORT (clk, pe: IN BIT; din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dch8 USE ENTITY WORK.dch8 (dch8a);
	COMPONENT dch9
		PORT (clk, pe: IN BIT; din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dch9 USE ENTITY WORK.dch9 (dch9a);
	COMPONENT dch10
		PORT (clk, pe: IN BIT; din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dch10 USE ENTITY WORK.dch10 (dch10a);
	COMPONENT dch11
		PORT (clk, pe: IN BIT; din: IN BIT_VECTOR(0 TO m-1);
			dout: OUT BIT_VECTOR(0 TO m-1));
		END COMPONENT;
		FOR ALL: dch11 USE ENTITY WORK.dch11 (dch11a);

	-- common signals generated by C program
	SIGNAL syn1, syn2, syn3, syn4, syn5, syn6, syn7, syn8, syn9, syn10, syn11, syn12, syn13, syn14, syn15, syn16, syn17, syn18, syn19, syn20, syn21: BIT_VECTOR(0 TO m-1);
	SIGNAL sn0out, sn1out, sn2out, sn3out, sn4out, sn5out, sn6out, sn7out, sn8out, sn9out, sn10out, sn11out, sn12out, sn13out, sn14out, sn15out, sn16out, sn17out, sn18out, sn19out, sn20out: BIT_VECTOR(0 TO m-1);
	SIGNAL sn0in, sn1in, sn2in, sn3in, sn4in, sn5in, sn6in, sn7in, sn8in, sn9in, sn10in, sn11in, sn12in, sn13in, sn14in, sn15in, sn16in, sn17in, sn18in, sn19in, sn20in: BIT_VECTOR(0 TO m-1);
	SIGNAL c1out, c2out, c3out, c4out, c5out, c6out, c7out, c8out, c9out, c10out, c11out: BIT_VECTOR(0 TO m-1);
	SIGNAL b3out, b4out, b5out, b6out, b7out, b8out, b9out, b10out, b11out: BIT_VECTOR(0 TO m-1);
	SIGNAL ch1out, ch2out, ch3out, ch4out, ch5out, ch6out, ch7out, ch8out, ch9out, ch10out, ch11out: BIT_VECTOR(0 TO m-1);

	-- for different option by C program
	SIGNAL b4set, b4sIn: BIT;
	SIGNAL sn0en, sn1en, sn2en, sn3en, sn4en, sn5en, sn6en, sn7en, sn8en, sn9en, sn10en, sn11en: BIT_VECTOR(0 TO m-1);
	SIGNAL cc2out, cc3out, cc4out, cc5out, cc6out, cc7out, cc8out, cc9out: BIT_VECTOR(0 TO m-1);
	SIGNAL b5in, b6in, b7in, b8in, b9in, b10in, b11in: BIT_VECTOR(0 TO m-1);
	COMPONENT dcount --counter
		PORT (clk, reset, drnzero: IN BIT;
		bsel, bufCe, bufkCe, chpe, msmpe, snce, synpe, vdout, vdout1, c0first, cce, caLast1, cbBeg, ca3a, ca4a, ca5a: OUT BIT);
		END COMPONENT;
		FOR ALL: dcount USE ENTITY WORK.dcount (dcounta);

	--  option 3 VHDL template
	SIGNAL  chpe, msmPe, msmCe, snce, synpe, vdout1, caLast: BIT;
	SIGNAL  cce, cbBeg: BIT;
		-- from counter - control signals
	SIGNAL err, bsel, bufCe, bufkCe: BIT;
	SIGNAL b3set, b3sIn, b2out, b2ce, b3ce, xbsel: BIT;
		-- bsel=1 - Br+1<- Br*x^2
	SIGNAL drnzero, dringPe, ccCe, qdr_or, qdr_orCe: BIT;
	SIGNAL one, c0first: BIT;
	SIGNAL c1in, cs, dr, dra, dr_or: BIT_VECTOR(0 TO m-1);
	SIGNAL drpd, qd, dli, dmIn, dm: BIT_VECTOR(0 TO m-1);
	SIGNAL cin: BIT_VECTOR(2 TO t);
	-- only for m=8
	SIGNAL xdaOut, xdbOut, xdcOut, xddOut, xdeOut: BIT_VECTOR(0 TO 7);
	SIGNAL d1L, d2L, d2La, d3L, dm1l, dxOut: BIT_VECTOR(0 TO 7);
	SIGNAL ca3, ca4, ca5, ca45: BIT;
  BEGIN
	b2: drd1ce
		PORT MAP (clk, b2ce, bsel, b2out);
	b3ce<= caLast AND NOT cbBeg;
	b2ce<= synpe OR b3ce;

	dr_or(0)<= dra(0);  -- dr_or<= dra(0) OR dra(1) ... OR dra(m-1)
	gen_dr:
	FOR i IN 1 TO m-1 GENERATE
		dr_or(i)<= dr_or(i-1) OR dra(i);
	END GENERATE;
	qdr_orCe<= synpe OR caLast;
	qdrOr: drd1ce
		PORT MAP (clk, qdr_orCe, dr_or(m-1), qdr_or);
	drnzero<= (synpe AND dr_or(m-1)) OR (NOT synpe AND qdr_or);
	msmCe<= NOT caLast;
	msm: dssbm
		PORT MAP (clk, msmce, msmpe, cs, dr);

	xdr: dmul21
		PORT MAP (synpe, dr, syn1, dra);

	inv: dinv
		PORT MAP (clk, cbBeg, bsel, caLast, cce, drnzero, snce, synpe, dra, drpd);
		-- c0first - count next to the last
	qdd: drdce
		PORT MAP (clk, caLast, drpd, qd);

	b3set<= synpe OR (b3ce AND NOT bsel);
	b3sIn<= synpe AND NOT drnzero;
	b3:  drdcesone
		PORT MAP (clk, b3ce, b3set, b3sIn, c1out, b3out);
	xbsel<= bsel OR cbBeg;  -- cbBeg to reset b:
	ccCe<= (msmPe AND cbBeg) OR caLast;
	c1in<= syn1(m-1) & syn1(0 TO m-2);
	c1: dshpe
		PORT MAP (clk, cce, synpe, c1in, c1out);
	cin(2)<= dm(0) AND b2out AND NOT cbBeg;

	-- only for m=8
	xda: dmul21
		PORT MAP (caLast, qd, drpd, xdaOut);
	mla: dmli	-- multiply by L^1
		PORT MAP (xdaOut, d1L);
	mlb: dmli	-- total L^2
		PORT MAP (d1L, d2L);
	mlc: dmli	-- total L^3
		PORT MAP (d2L, d3L);
	mlm: dmli	-- multiply dm by L^1
		PORT MAP (dm, dm1L);

	dring: drd
		PORT MAP(clk, dmIn, dm);
	xdb: dmul21
		PORT MAP (caLast, dxOut, d3L, dmIn);
	dx: dxorm
		PORT MAP (xdeOut, xdcOut, dxOut);
	ca45<= ca4 OR ca5;
	xdc: dmul21
		PORT MAP (ca45, dm1L, xddOut, xdcOut);
	xdd: dmul21
		PORT MAP (ca5, qd, d1L, xddOut);
	xde: dmul21
		PORT MAP (ca3, d2La, d3L, xdeOut);
	d2And: dandm
		PORT MAP (ca4, d2L, d2La);
	-- dmIn<= qd*L^3 <-caLast;  qd*(L^3+L^7) =qd*L^3+dm*L^1 <-ca3;
	-- qd*(L^0+L^2) <-ca4; qd*L^1 <-ca5; dm*L^1 <-default

	--------- for option 3 C program
	sn0e: dandm
		PORT MAP (c0first, sn0out, sn0en);
	sn1e: dandm
		PORT MAP (c1out(0), sn1out, sn1en);
	sn2e: dandm
		PORT MAP (c2out(0), sn2out, sn2en);
	sn3e: dandm
		PORT MAP (c3out(0), sn3out, sn3en);
	sn4e: dandm
		PORT MAP (c4out(0), sn4out, sn4en);
	sn5e: dandm
		PORT MAP (c5out(0), sn5out, sn5en);
	sn6e: dandm
		PORT MAP (c6out(0), sn6out, sn6en);
	sn7e: dandm
		PORT MAP (c7out(0), sn7out, sn7en);
	sn8e: dandm
		PORT MAP (c8out(0), sn8out, sn8en);
	sn9e: dandm
		PORT MAP (c9out(0), sn9out, sn9en);
	sn10e: dandm
		PORT MAP (c10out(0), sn10out, sn10en);
	sn11e: dandm
		PORT MAP (c11out(0), sn11out, sn11en);
	ms0: dxort
		PORT MAP (sn0en(0), sn1en(0), sn2en(0), sn3en(0), sn4en(0), sn5en(0), sn6en(0), sn7en(0), sn8en(0), sn9en(0), sn10en(0), sn11en(0), cs(0));
	ms1: dxort
		PORT MAP (sn0en(1), sn1en(1), sn2en(1), sn3en(1), sn4en(1), sn5en(1), sn6en(1), sn7en(1), sn8en(1), sn9en(1), sn10en(1), sn11en(1), cs(1));
	ms2: dxort
		PORT MAP (sn0en(2), sn1en(2), sn2en(2), sn3en(2), sn4en(2), sn5en(2), sn6en(2), sn7en(2), sn8en(2), sn9en(2), sn10en(2), sn11en(2), cs(2));
	ms3: dxort
		PORT MAP (sn0en(3), sn1en(3), sn2en(3), sn3en(3), sn4en(3), sn5en(3), sn6en(3), sn7en(3), sn8en(3), sn9en(3), sn10en(3), sn11en(3), cs(3));
	ms4: dxort
		PORT MAP (sn0en(4), sn1en(4), sn2en(4), sn3en(4), sn4en(4), sn5en(4), sn6en(4), sn7en(4), sn8en(4), sn9en(4), sn10en(4), sn11en(4), cs(4));
	ms5: dxort
		PORT MAP (sn0en(5), sn1en(5), sn2en(5), sn3en(5), sn4en(5), sn5en(5), sn6en(5), sn7en(5), sn8en(5), sn9en(5), sn10en(5), sn11en(5), cs(5));
	ms6: dxort
		PORT MAP (sn0en(6), sn1en(6), sn2en(6), sn3en(6), sn4en(6), sn5en(6), sn6en(6), sn7en(6), sn8en(6), sn9en(6), sn10en(6), sn11en(6), cs(6));
	ms7: dxort
		PORT MAP (sn0en(7), sn1en(7), sn2en(7), sn3en(7), sn4en(7), sn5en(7), sn6en(7), sn7en(7), sn8en(7), sn9en(7), sn10en(7), sn11en(7), cs(7));
	c2: dshr
		PORT MAP (clk, cce, cbBeg, cin(2), c2out);
	c3: dshr
		PORT MAP (clk, cce, cbBeg, cin(3), c3out);
	c4: dshr
		PORT MAP (clk, cce, cbBeg, cin(4), c4out);
	c5: dshr
		PORT MAP (clk, cce, cbBeg, cin(5), c5out);
	c6: dshr
		PORT MAP (clk, cce, cbBeg, cin(6), c6out);
	c7: dshr
		PORT MAP (clk, cce, cbBeg, cin(7), c7out);
	c8: dshr
		PORT MAP (clk, cce, cbBeg, cin(8), c8out);
	c9: dshr
		PORT MAP (clk, cce, cbBeg, cin(9), c9out);
	c10: dshr
		PORT MAP (clk, cce, cbBeg, cin(10), c10out);
	c11: dshr
		PORT MAP (clk, cce, cbBeg, cin(11), c11out);
	cc2: drdce
		PORT MAP (clk, ccCe, c2out, cc2out);
	cc3: drdce
		PORT MAP (clk, ccCe, c3out, cc3out);
	cc4: drdce
		PORT MAP (clk, ccCe, c4out, cc4out);
	cc5: drdce
		PORT MAP (clk, ccCe, c5out, cc5out);
	cc6: drdce
		PORT MAP (clk, ccCe, c6out, cc6out);
	cc7: drdce
		PORT MAP (clk, ccCe, c7out, cc7out);
	cc8: drdce
		PORT MAP (clk, ccCe, c8out, cc8out);
	cc9: drdce
		PORT MAP (clk, ccCe, c9out, cc9out);
	mb3: dsdbm
		PORT MAP (b3out, dm, cin(3));
	mb4: dsdbm
		PORT MAP (b4out, dm, cin(4));
	mb5: dsdbm
		PORT MAP (b5out, dm, cin(5));
	mb6: dsdbm
		PORT MAP (b6out, dm, cin(6));
	mb7: dsdbm
		PORT MAP (b7out, dm, cin(7));
	mb8: dsdbm
		PORT MAP (b8out, dm, cin(8));
	mb9: dsdbm
		PORT MAP (b9out, dm, cin(9));
	mb10: dsdbm
		PORT MAP (b10out, dm, cin(10));
	mb11: dsdbm
		PORT MAP (b11out, dm, cin(11));
	b4set<= caLast and NOT bsel;
	b4sIn<= NOT cbBeg AND b2out;
	b4: drdceSOne
		PORT MAP (clk, caLast, b4set, b4sIn, cc2out, b4out);
	b5: drdce
		PORT MAP (clk, caLast, b5in, b5out);
	b6: drdce
		PORT MAP (clk, caLast, b6in, b6out);
	b7: drdce
		PORT MAP (clk, caLast, b7in, b7out);
	b8: drdce
		PORT MAP (clk, caLast, b8in, b8out);
	b9: drdce
		PORT MAP (clk, caLast, b9in, b9out);
	b10: drdce
		PORT MAP (clk, caLast, b10in, b10out);
	b11: drdce
		PORT MAP (clk, caLast, b11in, b11out);
	xb5: dmul21
		PORT MAP (xbsel, b3out, cc3out, b5in);
	xb6: dmul21
		PORT MAP (xbsel, b4out, cc4out, b6in);
	xb7: dmul21
		PORT MAP (xbsel, b5out, cc5out, b7in);
	xb8: dmul21
		PORT MAP (xbsel, b6out, cc6out, b8in);
	xb9: dmul21
		PORT MAP (xbsel, b7out, cc7out, b9in);
	xb10: dmul21
		PORT MAP (xbsel, b8out, cc8out, b10in);
	xb11: dmul21
		PORT MAP (xbsel, b9out, cc9out, b11in);
	count: dcount
		PORT MAP (clk, reset, drnzero, bsel, bufCe, bufkCe, chpe, msmPe, snce, synpe, vdout, vdout1, c0first, cce, caLast, cbBeg, ca3, ca4, ca5);


	--------- common C program
	s1: dsyn1
		PORT MAP (clk, synpe, din,  syn1, syn2, syn4, syn8, syn16);
	s3: dsyn3
		PORT MAP (clk, synpe, din,  syn3, syn6, syn12);
	s5: dsyn5
		PORT MAP (clk, synpe, din,  syn5, syn10, syn20);
	s7: dsyn7
		PORT MAP (clk, synpe, din,  syn7, syn14);
	s9: dsyn9
		PORT MAP (clk, synpe, din,  syn9, syn18);
	s11: dsyn11
		PORT MAP (clk, synpe, din,  syn11);
	s13: dsyn13
		PORT MAP (clk, synpe, din,  syn13);
	s15: dsyn15
		PORT MAP (clk, synpe, din,  syn15);
	s17: dsyn17
		PORT MAP (clk, synpe, din,  syn17);
	s19: dsyn19
		PORT MAP (clk, synpe, din,  syn19);
	s21: dsyn21
		PORT MAP (clk, synpe, din,  syn21);
	x0: dmul21
		PORT MAP (synpe, sn19out, syn3, sn0in);
	x1: dmul21
		PORT MAP (synpe, sn20out, syn2, sn1in);
	x2: dmul21
		PORT MAP (synpe, sn0out, syn1, sn2in);
	x3: dmul21
		PORT MAP (synpe, sn1out, syn21, sn3in);
	x4: dmul21
		PORT MAP (synpe, sn2out, syn20, sn4in);
	x5: dmul21
		PORT MAP (synpe, sn3out, syn19, sn5in);
	x6: dmul21
		PORT MAP (synpe, sn4out, syn18, sn6in);
	x7: dmul21
		PORT MAP (synpe, sn5out, syn17, sn7in);
	x8: dmul21
		PORT MAP (synpe, sn6out, syn16, sn8in);
	x9: dmul21
		PORT MAP (synpe, sn7out, syn15, sn9in);
	x10: dmul21
		PORT MAP (synpe, sn8out, syn14, sn10in);
	x11: dmul21
		PORT MAP (synpe, sn9out, syn13, sn11in);
	x12: dmul21
		PORT MAP (synpe, sn10out, syn12, sn12in);
	x13: dmul21
		PORT MAP (synpe, sn11out, syn11, sn13in);
	x14: dmul21
		PORT MAP (synpe, sn12out, syn10, sn14in);
	x15: dmul21
		PORT MAP (synpe, sn13out, syn9, sn15in);
	x16: dmul21
		PORT MAP (synpe, sn14out, syn8, sn16in);
	x17: dmul21
		PORT MAP (synpe, sn15out, syn7, sn17in);
	x18: dmul21
		PORT MAP (synpe, sn16out, syn6, sn18in);
	x19: dmul21
		PORT MAP (synpe, sn17out, syn5, sn19in);
	x20: dmul21
		PORT MAP (synpe, sn18out, syn4, sn20in);
	sn0: drdce
		PORT MAP (clk, snce, sn0in, sn0out);
	sn1: drdce
		PORT MAP (clk, snce, sn1in, sn1out);
	sn2: drdce
		PORT MAP (clk, snce, sn2in, sn2out);
	sn3: drdce
		PORT MAP (clk, snce, sn3in, sn3out);
	sn4: drdce
		PORT MAP (clk, snce, sn4in, sn4out);
	sn5: drdce
		PORT MAP (clk, snce, sn5in, sn5out);
	sn6: drdce
		PORT MAP (clk, snce, sn6in, sn6out);
	sn7: drdce
		PORT MAP (clk, snce, sn7in, sn7out);
	sn8: drdce
		PORT MAP (clk, snce, sn8in, sn8out);
	sn9: drdce
		PORT MAP (clk, snce, sn9in, sn9out);
	sn10: drdce
		PORT MAP (clk, snce, sn10in, sn10out);
	sn11: drdce
		PORT MAP (clk, snce, sn11in, sn11out);
	sn12: drdce
		PORT MAP (clk, snce, sn12in, sn12out);
	sn13: drdce
		PORT MAP (clk, snce, sn13in, sn13out);
	sn14: drdce
		PORT MAP (clk, snce, sn14in, sn14out);
	sn15: drdce
		PORT MAP (clk, snce, sn15in, sn15out);
	sn16: drdce
		PORT MAP (clk, snce, sn16in, sn16out);
	sn17: drdce
		PORT MAP (clk, snce, sn17in, sn17out);
	sn18: drdce
		PORT MAP (clk, snce, sn18in, sn18out);
	sn19: drdce
		PORT MAP (clk, snce, sn19in, sn19out);
	sn20: drdce
		PORT MAP (clk, snce, sn20in, sn20out);
	ch1: dch1
		PORT MAP (clk, chpe, c1out, ch1out);
	ch2: dch2
		PORT MAP (clk, chpe, c2out, ch2out);
	ch3: dch3
		PORT MAP (clk, chpe, c3out, ch3out);
	ch4: dch4
		PORT MAP (clk, chpe, c4out, ch4out);
	ch5: dch5
		PORT MAP (clk, chpe, c5out, ch5out);
	ch6: dch6
		PORT MAP (clk, chpe, c6out, ch6out);
	ch7: dch7
		PORT MAP (clk, chpe, c7out, ch7out);
	ch8: dch8
		PORT MAP (clk, chpe, c8out, ch8out);
	ch9: dch9
		PORT MAP (clk, chpe, c9out, ch9out);
	ch10: dch10
		PORT MAP (clk, chpe, c10out, ch10out);
	ch11: dch11
		PORT MAP (clk, chpe, c11out, ch11out);
	cheg: dcheq
		PORT MAP (ch1out, ch2out, ch3out, ch4out, ch5out, ch6out, ch7out, ch8out, ch9out, ch10out, ch11out,  err);

	--- common for all option VHDL template
	one<= '1';
	buf: dbuf
		PORT MAP (clk, bufCe, bufkCe, err, vdout1, din, dout);
END deca;
